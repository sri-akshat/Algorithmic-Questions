Index: src/su/dataStructure/Vertex.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/su/dataStructure/Vertex.java	(date 1421251729000)
+++ src/su/dataStructure/Vertex.java	(date 1421251729000)
@@ -1,8 +1,6 @@
 package su.dataStructure;
 
-import java.util.ArrayList;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 
 /**
@@ -50,6 +48,11 @@
     public void addEdge(Edge edge) {
 
         this.edges.add(edge);
+    }
+
+    public void addEdge(Vertex v2) {
+
+        this.edges.add(new Edge(this,v2));
     }
 
     public Edge getMinEdge() {
\ No newline at end of file
Index: src/su/problems/AllSourceToDestinationPaths.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/su/problems/AllSourceToDestinationPaths.java	(date 1421251729000)
+++ src/su/problems/AllSourceToDestinationPaths.java	(date 1421251729000)
@@ -0,0 +1,58 @@
+package su.problems;
+
+import su.dataStructure.Edge;
+import su.dataStructure.Graph;
+import su.dataStructure.Vertex;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Created by Akshat on 1/17/2015.
+ *
+ * Given a directed graph, a source vertex ‘s’ and a destination vertex ‘d’, print all paths from given ‘s’ to ‘d’.
+
+ Consider the following directed graph. Let the s be 2 and d be 3. There are 4 different paths from 2 to 3.
+
+ 2=0->3
+ \ | /
+   1
+
+ 2 to 3
+ 2->1->3
+ 2->0->3
+ 2->0->1->3
+
+ *
+ */
+public class AllSourceToDestinationPaths {
+    public List<String> compute(Graph graph, Vertex start, Vertex end) {
+        return traverseGraph(start, end, "", new ArrayList<String>(), new HashSet<>());
+    }
+
+    private List<String> traverseGraph(Vertex current, Vertex end, String path, List<String> paths, Set<Integer> pathTracker) {
+
+        if(current == end)
+        {
+            path += current.getData()+"-";
+            paths.add(path.substring(0, path.length()-1));
+            return paths;
+        }
+
+        if(pathTracker.contains(current.getData()))
+        {
+            return paths;
+        }
+
+        for(Edge edge : (Set<Edge>)current.getEdges())
+        {
+            Set<Integer> newPathTracker = new HashSet<>(pathTracker);
+            newPathTracker.add((Integer) current.getData());
+            traverseGraph(edge.getVertex2(), end, path + current.getData() + "-", paths, newPathTracker);
+        }
+
+        return paths;
+    }
+}
Index: src/su/problems/BSTSum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/su/problems/BSTSum.java	(date 1421251729000)
+++ src/su/problems/BSTSum.java	(date 1421251729000)
@@ -0,0 +1,21 @@
+package su.problems;
+
+import su.dataStructure.Node;
+
+/**
+ * Created by Akshat on 1/18/2015.
+ */
+public class BSTSum {
+    public int compute(Node node, int sum){
+
+        if(node.right!=null)
+            sum = compute(node.right, sum);
+
+        sum += node.getIntData();
+        node.setData(sum);
+
+        if(node.left!=null)
+            sum = compute(node.left, sum);
+        return sum;
+    }
+}
Index: src/su/problems/IncreasingDecreasingArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/su/problems/IncreasingDecreasingArray.java	(date 1421251729000)
+++ src/su/problems/IncreasingDecreasingArray.java	(date 1421251729000)
@@ -0,0 +1,71 @@
+package su.problems;
+
+/**
+ * Created by Akshat on 1/18/2015.
+ *
+ *  Find element in an array which have elements in first increasing and then decreasing order.
+ *
+ */
+public class IncreasingDecreasingArray {
+
+    public boolean search(int[] array, int query){
+
+        int hillTop = hillTopBST(array, 0, array.length-1);
+        return bst(array, query, 0, hillTop) || rBST(array, query, hillTop+1, array.length-1);
+    }
+
+    private int hillTopBST(int[] array, int start, int end)
+    {
+        if(start>end)
+            return -1;
+
+        int mid = (start + end)/2;
+        if(array[mid]>array[mid-1] && array[mid]>array[mid+1])
+        {
+            return mid;
+        }
+
+        if(array[mid]>array[mid-1] && array[mid]<array[mid+1])
+            return hillTopBST(array, mid+1, end);
+        if(array[mid]<array[mid-1] && array[mid]>array[mid+1])
+            return hillTopBST(array, start, mid-1);
+
+        return -1;
+    }
+
+    private boolean bst(int[] array, int query, int start, int end)
+    {
+        if(start>end)
+            return false;
+
+        int mid = (start+end)/2;
+
+        if(query == array[mid])
+            return true;
+        if(query > array[mid])
+            return bst(array, query, mid+1, end);
+        if(query < array[mid])
+            return bst(array, query, start, mid-1);
+
+        return false;
+    }
+
+
+
+    private boolean rBST(int[] array, int query, int start, int end)
+    {
+        if(start>end)
+            return false;
+
+        int mid = (start+end)/2;
+
+        if(query == array[mid])
+            return true;
+        if(query < array[mid])
+            return bst(array, query, mid+1, end);
+        if(query > array[mid])
+            return bst(array, query, start, mid-1);
+
+        return false;
+    }
+}
Index: src/su/problems/PruneTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/su/problems/PruneTree.java	(date 1421251729000)
+++ src/su/problems/PruneTree.java	(date 1421251729000)
@@ -0,0 +1,74 @@
+package su.problems;
+
+import su.dataStructure.Node;
+
+/**
+ * Created by Akshat on 1/16/2015.
+ *
+ * Given a Binary Tree and a number k, remove all nodes that lie only on root to leaf path(s) of length smaller than k. If a node X lies on multiple root-to-leaf paths and if any of the paths has path length >= k, then X is not deleted from Binary Tree. In other words a node is deleted if all paths going through it have lengths smaller than k.
+
+ Consider the following example Binary Tree
+
+ 1
+ /      \
+ 2          3
+ /     \         \
+ 4         5        6
+ /                   /
+ 7                   8
+ Input: Root of above Binary Tree
+ k = 4
+
+ Output: The tree should be changed to following
+ 1
+ /     \
+ 2          3
+ /             \
+ 4                 6
+ /                  /
+ 7                  8
+ There are 3 paths
+ i) 1->2->4->7      path length = 4
+ ii) 1->2->5        path length = 3
+ iii) 1->3->6->8    path length = 4
+ There is only one path " 1->2->5 " of length smaller than 4.
+ The node 5 is the only node that lies only on this path, so
+ node 5 is removed.
+ Nodes 2 and 1 are not removed as they are parts of other paths
+ of length 4 as well.
+
+ If k is 5 or greater than 5, then whole tree is deleted.
+
+ If k is 3 or less than 3, then nothing is deleted.
+ *
+ */
+public class PruneTree
+{
+    public int removeNodeForLTkLength(Node node, int k, int level) {
+
+        int leftLen = -1;
+        int rightLen = -1;
+
+        if(node.left!=null){
+            leftLen = removeNodeForLTkLength(node.left,k,level+1);
+        }
+
+        if(node.right!=null){
+            rightLen = removeNodeForLTkLength(node.right,k, level+1);
+        }
+
+        if(leftLen < level)
+            leftLen = level;
+
+        if(rightLen < level)
+            rightLen = level;
+
+        if(Math.max(leftLen, rightLen) < k)
+        {
+            System.out.println("deleted "+node.getData());
+            node.setData(null);
+        }
+
+        return Math.max(leftLen, rightLen);
+    }
+}
Index: src/su/problems/RootToLeafSum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/su/problems/RootToLeafSum.java	(date 1421251729000)
+++ src/su/problems/RootToLeafSum.java	(date 1421251729000)
@@ -0,0 +1,28 @@
+package su.problems;
+
+import su.dataStructure.Node;
+
+import java.util.List;
+
+/**
+ * Created by Akshat on 1/18/2015.
+ */
+public class RootToLeafSum {
+    public List<Integer> compute(Node node, int sum, List<Integer> list){
+
+        if(node.left!=null){
+            compute(node.left, sum+node.getIntData(), list);
+        }
+
+        if(node.right!=null){
+            compute(node.right, sum+node.getIntData(), list);
+        }
+
+        if(node.left==null && node.right==null)
+        {
+            list.add(sum+node.getIntData());
+        }
+        return list;
+    }
+
+}
Index: src/su/problems/TreeDiameter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/su/problems/TreeDiameter.java	(date 1421251729000)
+++ src/su/problems/TreeDiameter.java	(date 1421251729000)
@@ -0,0 +1,27 @@
+package su.problems;
+
+import su.dataStructure.Node;
+
+/**
+ * Created by Akshat on 1/19/2015.
+ */
+public class TreeDiameter {
+
+    int maxDia = 0;
+    public int compute(Node node) {
+
+        int leftDia = -1;
+        int rightDia = -1;
+
+        if(node.left!=null)
+            leftDia = compute(node.left);
+
+        if(node.right!=null)
+            rightDia = compute(node.right);
+
+        if(leftDia+rightDia > maxDia)
+            maxDia = leftDia+rightDia;
+
+        return maxDia;
+    }
+}
Index: src/su/problems/TreeRelation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/su/problems/TreeRelation.java	(date 1421251729000)
+++ src/su/problems/TreeRelation.java	(date 1421251729000)
@@ -0,0 +1,56 @@
+package su.problems;
+
+import su.dataStructure.Node;
+
+import java.util.LinkedList;
+import java.util.Queue;
+
+/**
+ * Created by Akshat on 1/18/2015.
+ */
+public class TreeRelation {
+
+    public boolean areCousins(Node root, int x, int y)
+    {
+        Queue<Node> queue = new LinkedList<Node>();
+        queue.add(root);
+        queue.add(null);
+
+        do{
+            Node curr = queue.remove();
+            if(curr==null){
+                if(queue.peek()!=null)
+                    queue.add(null);
+                else
+                    break;
+            }else{
+                if(curr.getIntData()==x){
+                    while(queue.peek()!=null){
+                        curr = queue.remove();
+                        if(curr.getIntData()==y)
+                        {
+                            return true;
+                        }
+                    }
+                    return false;
+                }
+
+                if(curr.getIntData()==y){
+                    while(queue.peek()!=null){
+                        curr = queue.remove();
+                        if(curr.getIntData()==x)
+                        {
+                            return true;
+                        }
+                    }
+                    return false;
+                }
+
+                queue.add(curr.left);
+                queue.add(curr.right);
+            }
+        }while(true);
+
+        return false;
+    }
+}
Index: testSrc/su/problems/TestAllSourceToDestinationPaths.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- testSrc/su/problems/TestAllSourceToDestinationPaths.java	(date 1421251729000)
+++ testSrc/su/problems/TestAllSourceToDestinationPaths.java	(date 1421251729000)
@@ -0,0 +1,42 @@
+package su.problems;
+
+import org.junit.Assert;
+import su.dataStructure.Graph;
+import su.dataStructure.Vertex;
+
+import java.util.List;
+
+/**
+ * Created by Akshat on 1/17/2015.
+ */
+public class TestAllSourceToDestinationPaths {
+
+    @org.junit.Test
+    public void testCompute()
+    {
+        Graph graph = new Graph();
+        Vertex<Integer> v2 = new Vertex<>(2);
+        graph.addVertex(v2);
+        Vertex<Integer> v0 = new Vertex<>(0);
+        graph.addVertex(v0);
+        Vertex<Integer> v1 = new Vertex<>(1);
+        graph.addVertex(v1);
+        Vertex<Integer> v3 = new Vertex<>(3);
+        graph.addVertex(v3);
+
+        v2.addEdge(v0);
+        v2.addEdge(v1);
+
+        v0.addEdge(v2);
+        v0.addEdge(v1);
+        v0.addEdge(v3);
+
+        v1.addEdge(v3);
+
+        AllSourceToDestinationPaths allSourceToDestinationPaths = new AllSourceToDestinationPaths();
+        List<String> paths = allSourceToDestinationPaths.compute(graph, v2, v3);
+        Assert.assertTrue(paths.contains("2-1-3"));
+        Assert.assertTrue(paths.contains("2-0-3"));
+        Assert.assertTrue(paths.contains("2-0-1-3"));
+    }
+}
Index: testSrc/su/problems/TestBSTSum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- testSrc/su/problems/TestBSTSum.java	(date 1421251729000)
+++ testSrc/su/problems/TestBSTSum.java	(date 1421251729000)
@@ -0,0 +1,26 @@
+package su.problems;
+
+import org.junit.Assert;
+import su.TestUtils;
+import su.dataStructure.Node;
+
+/**
+ * Created by Akshat on 1/18/2015.
+ */
+public class TestBSTSum {
+
+    @org.junit.Test
+    public void testCompute()
+    {
+        Node node = TestUtils.createBinaryTree();
+        BSTSum bstSum = new BSTSum();
+        bstSum.compute(node,0);
+        Assert.assertEquals(70, node.getIntData().intValue());
+        Assert.assertEquals(83, node.left.getIntData().intValue());
+        Assert.assertEquals(38, node.right.getIntData().intValue());
+        Assert.assertEquals(86, node.left.left.getIntData().intValue());
+        Assert.assertEquals(77, node.left.right.getIntData().intValue());
+        Assert.assertEquals(20, node.right.right.getIntData().intValue());
+        Assert.assertEquals(55, node.right.left.getIntData().intValue());
+    }
+}
Index: testSrc/su/problems/TestIncreasingDecreasingArray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- testSrc/su/problems/TestIncreasingDecreasingArray.java	(date 1421251729000)
+++ testSrc/su/problems/TestIncreasingDecreasingArray.java	(date 1421251729000)
@@ -0,0 +1,29 @@
+package su.problems;
+
+import org.junit.Assert;
+
+/**
+ * Created by Akshat on 1/18/2015.
+ */
+public class TestIncreasingDecreasingArray {
+
+    @org.junit.Test
+    public void testSearch()
+    {
+        int[] arr = {8, 10, 20, 80, 100, 200, 400, 500, 3, 2, 1};
+        IncreasingDecreasingArray increasingDecreasingArray = new IncreasingDecreasingArray();
+        Assert.assertTrue(increasingDecreasingArray.search(arr, 10));
+        Assert.assertTrue(increasingDecreasingArray.search(arr, 500));
+        Assert.assertTrue(increasingDecreasingArray.search(arr, 1));
+        Assert.assertTrue(increasingDecreasingArray.search(arr, 2));
+    }
+
+    @org.junit.Test
+    public void testSearch1()
+    {
+        int[] arr = {8, 10, 20, 80, 100, 200, 400, 500, 3, 2, 1};
+        IncreasingDecreasingArray increasingDecreasingArray = new IncreasingDecreasingArray();
+        Assert.assertFalse(increasingDecreasingArray.search(arr, 11));
+    }
+}
+
Index: testSrc/su/problems/TestPruneTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- testSrc/su/problems/TestPruneTree.java	(date 1421251729000)
+++ testSrc/su/problems/TestPruneTree.java	(date 1421251729000)
@@ -0,0 +1,60 @@
+package su.problems;
+
+import org.junit.Assert;
+import su.TestUtils;
+import su.dataStructure.Node;
+
+import java.util.ArrayList;
+
+/**
+ * Created by Akshat on 1/16/2015.
+ */
+public class TestPruneTree {
+
+    @org.junit.Test
+    public void testRemoveNodeForLTkLength()
+    {
+        Node binaryTree = TestUtils.createBinaryTree(getIntegerList());
+        PruneTree pruneTree = new PruneTree();
+        Assert.assertNotNull(binaryTree.left.right);
+        binaryTree.setLevel(1);
+        pruneTree.removeNodeForLTkLength(binaryTree, 4, 1);
+        Assert.assertNull(binaryTree.left.right.getData());
+    }
+
+    @org.junit.Test
+    public void testRemoveNodeForLTkLength1()
+    {
+        Node binaryTree = TestUtils.createBinaryTree(getIntegerList());
+        PruneTree pruneTree = new PruneTree();
+        Assert.assertNotNull(binaryTree.left.right);
+        binaryTree.setLevel(1);
+        pruneTree.removeNodeForLTkLength(binaryTree, 5, 1);
+        Assert.assertNull(binaryTree.getData());
+        Assert.assertNull(binaryTree.left.getData());
+        Assert.assertNull(binaryTree.right.getData());
+        Assert.assertNull(binaryTree.left.right.getData());
+        Assert.assertNull(binaryTree.left.left.getData());
+        Assert.assertNull(binaryTree.right.right.getData());
+    }
+
+    private static ArrayList<Integer> getIntegerList() {
+        ArrayList<Integer> numbers = new ArrayList<Integer>();
+        numbers.add(-1);  // unused 0th index
+        numbers.add(1);
+        numbers.add(2);
+        numbers.add(3);
+        numbers.add(4);
+        numbers.add(5);
+        numbers.add(null);
+        numbers.add(6);
+        numbers.add(7);
+        numbers.add(null);
+        numbers.add(null);
+        numbers.add(null);
+        numbers.add(null);
+        numbers.add(null);
+        numbers.add(8);
+        return numbers;
+    }
+}
Index: testSrc/su/problems/TestRootToLeafSum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- testSrc/su/problems/TestRootToLeafSum.java	(date 1421251729000)
+++ testSrc/su/problems/TestRootToLeafSum.java	(date 1421251729000)
@@ -0,0 +1,27 @@
+package su.problems;
+
+import org.junit.Assert;
+import su.TestUtils;
+import su.dataStructure.Node;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by Akshat on 1/18/2015.
+ */
+public class TestRootToLeafSum {
+
+    @org.junit.Test
+    public void testCompute()
+    {
+        Node node = TestUtils.createBinaryTree();
+        RootToLeafSum rootToLeafSum = new RootToLeafSum();
+        List<Integer> list = rootToLeafSum.compute(node, 0, new ArrayList<Integer>());
+        Assert.assertEquals(4, list.size());
+        Assert.assertTrue(list.contains(24));
+        Assert.assertTrue(list.contains(28));
+        Assert.assertTrue(list.contains(50));
+        Assert.assertTrue(list.contains(53));
+    }
+}
Index: testSrc/su/problems/TestTreeDiameter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- testSrc/su/problems/TestTreeDiameter.java	(date 1421251729000)
+++ testSrc/su/problems/TestTreeDiameter.java	(date 1421251729000)
@@ -0,0 +1,19 @@
+package su.problems;
+
+import org.junit.Assert;
+import su.TestUtils;
+import su.dataStructure.Node;
+
+/**
+ * Created by Akshat on 1/19/2015.
+ */
+public class TestTreeDiameter {
+
+    @org.junit.Test
+    public void testCompute()
+    {
+        Node node = TestUtils.createBinaryTree();
+        TreeDiameter longestDistanceBetween2Nodes = new TreeDiameter();
+        Assert.assertEquals(4, longestDistanceBetween2Nodes.compute(node));
+    }
+}
Index: testSrc/su/problems/TestTreeRelation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- testSrc/su/problems/TestTreeRelation.java	(date 1421251729000)
+++ testSrc/su/problems/TestTreeRelation.java	(date 1421251729000)
@@ -0,0 +1,27 @@
+package su.problems;
+
+import org.junit.Assert;
+import su.TestUtils;
+import su.dataStructure.Node;
+
+/**
+ * Created by Akshat on 1/18/2015.
+ */
+public class TestTreeRelation {
+
+    @org.junit.Test
+    public void testAreCousins()
+    {
+        Node node = TestUtils.createBinaryTree();
+        TreeRelation treeRelation = new TreeRelation();
+        Assert.assertTrue(treeRelation.areCousins(node, 3, 17));
+    }
+
+    @org.junit.Test
+    public void testAreCousins1()
+    {
+        Node node = TestUtils.createBinaryTree();
+        TreeRelation treeRelation = new TreeRelation();
+        Assert.assertFalse(treeRelation.areCousins(node, 3, 15));
+    }
+}
